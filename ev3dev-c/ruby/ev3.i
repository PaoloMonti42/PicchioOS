
/*  ev3.i was generated by yup.py (yupp) 0.9b1
    out of ev3.yu-i at 2015-11-11 15:30
 *//**
 *  \file  ev3.i (ev3.yu-i)
 *  \brief  SWIG interface file.
 *  \author  Vitaly Kravtsov (in4lio@gmail.com)
 *  \copyright  See the LICENSE file.
 */

%module ev3
%include "cstring.i"
%include "stdint.i"
%include "typemaps.i"

%{
#include "../source/ev3/ev3.h"
#include "../source/ev3/ev3_led.h"
#include "../source/ev3/ev3_light.h"
#include "../source/ev3/ev3_port.h"
#include "../source/ev3/ev3_sensor.h"
#include "../source/ev3/ev3_tacho.h"
#include "../source/ev3/ev3_dc.h"
#include "../source/ev3/ev3_servo.h"
%}

%define ALLOC_OUTPUT_BUFFER(TYPEMAP,MAX)
%typemap(in,noblock=1,numinputs=0) TYPEMAP (char temp[MAX+1]) {
  $1 =  temp;
}
%enddef

/* String buffer without size is passed only for getting a port name */
ALLOC_OUTPUT_BUFFER( char *buf, 64 );

/* Unfortunately incompatible with %typemap( default ) size_t sz { $1 = DEFAULT_BUF_SIZE; } */
%cstring_output_maxsize( char *buf, size_t sz );

%include "./platform.h"

#ifdef SWIGPERL
/* because of the problem with SWIG_From_bool on the brick... */
#define bool  int

#endif

%apply uint8_t *OUTPUT { uint8_t *sn };
%apply bool *OUTPUT { bool *buf };
%apply int *OUTPUT { int *buf };
%apply uint8_t *OUTPUT { uint8_t *buf };
%apply uint8_t *OUTPUT { byte *buf };
%apply uint32_t *OUTPUT { uint32_t *buf };
%apply uint32_t *OUTPUT { dword *buf };
%apply float *OUTPUT { float *buf };
%apply uint8_t *OUTPUT { FLAGS_T *flags };

%apply uint32_t { dword };
%apply uint8_t { byte };
%apply uint8_t { INX_T };
%apply uint8_t { FLAGS_T };

#ifdef SWIGRUBY
%typemap( out ) size_t, bool { $result = $1 ? Qtrue : Qfalse; };
%typemap( in ) bool { $1 = $input == Qtrue ? 1 : 0; };

#endif

%typemap( default ) uint8_t from { $1 = 0; };

/*
 *  ev3
 */

// CLIENT ////////////////////////////////////////
#if EV3_BRICK == 0

%rename( brick_addr ) ev3_brick_addr;
extern char *ev3_brick_addr;
%rename( brick_port ) ev3_brick_port;
extern uint16_t ev3_brick_port;

//////////////////////////////////////////////////
#endif

extern int ev3_init( void );
extern void ev3_uninit( void );

extern size_t ev3_write_binary( const char *fn, char *STRING, size_t LENGTH );
extern size_t ev3_write( const char *fn, char *value );
extern size_t ev3_write_bool( const char *fn, bool value );
extern size_t ev3_write_int( const char *fn, int value );
extern size_t ev3_write_dword( const char *fn, uint32_t value );
extern size_t ev3_write_byte( const char *fn, uint8_t value );
extern size_t ev3_write_float( const char *fn, float value );

extern size_t ev3_read_binary( const char *fn, char *buf, size_t sz );
extern size_t ev3_read( const char *fn, char *buf, size_t sz );

#ifndef SWIGRUBY
extern size_t ev3_read_bool( const char *fn, bool *buf );

#endif
extern size_t ev3_read_int( const char *fn, int *buf );
extern size_t ev3_read_dword( const char *fn, uint32_t *buf );
extern size_t ev3_read_byte( const char *fn, uint8_t *buf );
extern size_t ev3_read_float( const char *fn, float *buf );

extern size_t ev3_listdir( const char *fn, char *buf, size_t sz );
extern size_t ev3_read_keys( uint8_t *buf );
extern bool ev3_poweroff( void );

enum {
	EV3_KEY__NONE_ = 0,

	EV3_KEY_UP     = 0x01L,
	EV3_KEY_DOWN   = 0x02L,
	EV3_KEY_LEFT   = 0x04L,
	EV3_KEY_RIGHT  = 0x08L,
	EV3_KEY_CENTER = 0x10L,
	EV3_KEY_BACK   = 0x20L,
};

/**
 *  \brief Identifiers of LEDs.
 */
enum {
	EV3_LEFT_GREEN,
	EV3_RIGHT_GREEN,
	EV3_LEFT_RED,
	EV3_RIGHT_RED,
	LED_OUTA,
	LED_OUTB,
	LED_OUTC,
	LED_OUTD,

	LED__COUNT_  /**< Count of EV3 LEDs. */
};

/**
 *  \brief Triggers identifiers of LEDs.
 */
enum {
	TRIGGER_NONE,
	TRIGGER_MMC0,
	TRIGGER_TIMER,
	TRIGGER_HEARTBEAT,
	TRIGGER_DEFAULT_ON,
	TRIGGER_TRANSIENT,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_OR_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING,
	TRIGGER_LEGOEV3_BATTERY_FULL,
	TRIGGER_LEGOEV3_BATTERY_CHARGING_BLINK_FULL_SOLID,
	TRIGGER_RFKILL0,
	TRIGGER_PHY0RX,
	TRIGGER_PHY0TX,
	TRIGGER_PHY0ASSOC,
	TRIGGER_PHY0RADIO,
	TRIGGER_RFKILL1,

	TRIGGER__COUNT_  /**< Count of EV3 triggers. */
};

#define LED_ATTR__COUNT_ 5

/**
 *  \brief Read "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Write "brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_brightness( uint8_t inx, byte value );

/**
 *  \brief Read "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_delay_off( uint8_t inx, int *buf );

/**
 *  \brief Write "delay_off" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_off( uint8_t inx, int value );

/**
 *  \brief Read "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_delay_on( uint8_t inx, int *buf );

/**
 *  \brief Write "delay_on" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_delay_on( uint8_t inx, int value );

/**
 *  \brief Read "max_brightness" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_led_max_brightness( uint8_t inx, byte *buf );

/**
 *  \brief Read "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_led_trigger( uint8_t inx, char *buf, size_t sz );

/**
 *  \brief Write "trigger" attribute of the LED.
 *  \param inx Index of the LED.
 *  \param value Attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger( uint8_t inx, char *value );

/**
 *  \brief Read "trigger" attribute of the LED and get the index.
 *  \param inx Index of the LED.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern INX_T get_led_trigger_inx( uint8_t inx );

/**
 *  \brief Write "trigger" attribute of the LED by the index.
 *  \param inx Index of the LED.
 *  \param trigger_inx Index of the trigger.
 *  \return Count of written bytes.
 */
extern size_t set_led_trigger_inx( uint8_t inx, INX_T trigger_inx );

/**
 *  \brief Get name of the specified LED trigger.
 *  \param trigger_inx Index of the trigger.
 *  \return Requested value.
 */
extern const char *ev3_led_trigger( INX_T trigger_inx );

/**
 *  \brief Identifiers of light locations.
 */
enum {
	LIT_LEFT,
	LIT_RIGHT,

	LIT__LOC__
};

/**
 *  \brief Identifiers of light colors.
 */
enum {
	LIT_OFF,
	LIT_GREEN,
	LIT_RED,
	LIT_AMBER,

	LIT__COL__
};

/**
 *  \brief Light colors.
 */
extern const char * const LIT_COLOR[] = { "OFF", "GREEN", "RED", "AMBER", STR_unknown_ };

/**
 *  \brief Get the light color name.
 *  \param col Color.
 *  \return Color name.
 */
extern const char *light_color( uint8_t col );

/**
 *  \brief Set the light color.
 *  \param loc Location.
 *  \param col Color.
 */
extern void set_light( uint8_t loc, uint8_t col );

/**
 *  \brief Get the light color.
 *  \param loc Location.
 *  \return Color.
 */
extern uint8_t get_light( uint8_t loc );

/**
 *  \brief Set the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \param trigger Index of trigger.
 */
extern void set_light_trigger( uint8_t loc, uint8_t col, uint8_t trigger );

/**
 *  \brief Get the light trigger.
 *  \param loc Location.
 *  \param col Color.
 *  \return Index of trigger or TRIGGER__COUNT_ - error has occurred.
 */
extern uint8_t get_light_trigger( uint8_t loc, uint8_t col );

/**
 *  \brief Set the light blink.
 *  \param loc Location.
 *  \param col Color.
 *  \param delay_on Time of "on" state in ms.
 *  \param delay_off Time of "off" state in ms.
 */
extern void set_light_blink( uint8_t loc, uint8_t col, int delay_on, int delay_off );

/**
 *  \brief Check the light is blinking.
 *  \param loc Location.
 *  \param col Color.
 *  \return Flag - the light is blinking.
 */
extern bool get_light_blink( uint8_t loc, uint8_t col );

#define PORT_DIR  "/sys/class/lego-port"  /**< Directory of EV3 ports. */

/**
 *  \brief Structure of a EV3 port descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< EV3 port type. */
	uint8_t port;  /**< EV3 port EV3 port. */
	uint8_t extport;  /**< EV3 port extended port. */
	uint8_t addr;  /**< EV3 port address. */

} EV3_PORT;

#define PORT_DESC__LIMIT_  64  /**< Limit of EV3 port descriptors. */

#define PORT__NONE_  PORT_DESC__LIMIT_  /**< EV3 port is not found. */

/**
 *  \brief Vector of EV3 port descriptors (filled by \ref ev3_port_init).
 */
extern EV3_PORT ev3_port[ PORT_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of EV3 port types.
 */
enum {
	PORT_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	HT_NXT_SMUX_PORT,
	LEGOEV3_INPUT_PORT,
	LEGOEV3_OUTPUT_PORT,
	MS_EV3_SMUX_PORT,
	MS_NXTMMX_OUT_PORT,
	WEDO_PORT,

	PORT_TYPE__COUNT_,  /**< Count of EV3 port types. */
	PORT_TYPE__UNKNOWN_ = PORT_TYPE__COUNT_
};

/**
 *  \brief Identifiers of EV3 port modes.
 */
enum {
	PORT_MODE__NONE_ = 0,

	HT_NXT_SMUX_PORT_ANALOG, HT_NXT_SMUX_ANALOG = HT_NXT_SMUX_PORT_ANALOG,
	HT_NXT_SMUX_PORT_I2C, HT_NXT_SMUX_I2C = HT_NXT_SMUX_PORT_I2C,

	LEGOEV3_INPUT_PORT_AUTO, INPUT_AUTO = LEGOEV3_INPUT_PORT_AUTO,
	LEGOEV3_INPUT_PORT_NXT_ANALOG, INPUT_NXT_ANALOG = LEGOEV3_INPUT_PORT_NXT_ANALOG,
	LEGOEV3_INPUT_PORT_NXT_COLOR, INPUT_NXT_COLOR = LEGOEV3_INPUT_PORT_NXT_COLOR,
	LEGOEV3_INPUT_PORT_NXT_I2C, INPUT_NXT_I2C = LEGOEV3_INPUT_PORT_NXT_I2C,
	LEGOEV3_INPUT_PORT_EV3_ANALOG, INPUT_EV3_ANALOG = LEGOEV3_INPUT_PORT_EV3_ANALOG,
	LEGOEV3_INPUT_PORT_EV3_UART, INPUT_EV3_UART = LEGOEV3_INPUT_PORT_EV3_UART,
	LEGOEV3_INPUT_PORT_OTHER_UART, INPUT_OTHER_UART = LEGOEV3_INPUT_PORT_OTHER_UART,
	LEGOEV3_INPUT_PORT_RAW, INPUT_RAW = LEGOEV3_INPUT_PORT_RAW,

	LEGOEV3_OUTPUT_PORT_AUTO, OUTPUT_AUTO = LEGOEV3_OUTPUT_PORT_AUTO,
	LEGOEV3_OUTPUT_PORT_EV3_TACHO_MOTOR, OUTPUT_EV3_TACHO_MOTOR = LEGOEV3_OUTPUT_PORT_EV3_TACHO_MOTOR,
	LEGOEV3_OUTPUT_PORT_RCX_MOTOR, OUTPUT_RCX_MOTOR = LEGOEV3_OUTPUT_PORT_RCX_MOTOR,
	LEGOEV3_OUTPUT_PORT_RCX_LED, OUTPUT_RCX_LED = LEGOEV3_OUTPUT_PORT_RCX_LED,
	LEGOEV3_OUTPUT_PORT_RAW, OUTPUT_RAW = LEGOEV3_OUTPUT_PORT_RAW,

	MS_EV3_SMUX_PORT_UART, MS_EV3_SMUX_UART = MS_EV3_SMUX_PORT_UART,
	MS_EV3_SMUX_PORT_ANALOG, MS_EV3_SMUX_ANALOG = MS_EV3_SMUX_PORT_ANALOG,

	MS_NXTMMX_OUT_PORT_TACHO_MOTOR, MS_NXTMMX_TACHO_MOTOR = MS_NXTMMX_OUT_PORT_TACHO_MOTOR,

	WEDO_PORT_AUTO, WEDO_AUTO = WEDO_PORT_AUTO,

	PORT_MODE__COUNT_,  /**< Count of EV3 port modes. */
	PORT_MODE__UNKNOWN_ = PORT_MODE__COUNT_
};

/**
 *  \brief Read "driver_name" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "mode" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "mode" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_port_mode( uint8_t sn, char *value );

/**
 *  \brief Read "modes" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "port_name" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "set_device" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_port_set_device( uint8_t sn, char *value );

/**
 *  \brief Read "status" attribute of the EV3 port.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_port_status( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get name of the specified EV3 port type.
 *  \param type_inx Index of the EV3 port type.
 *  \return Requested value.
 */
extern const char *ev3_port_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the EV3 port type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_port_type_inx( uint8_t sn );

/**
 *  \brief Read the EV3 port attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_port_desc( uint8_t sn, EV3_PORT *desc );

/**
 *  \brief Get descriptor of the EV3 port.
 *  \param sn Sequence number.
 *  \return Pointer to the EV3 port descriptor.
 */
extern EV3_PORT *ev3_port_desc( uint8_t sn );

/**
 *  \brief Get type from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_port_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_extport( uint8_t sn );

/**
 *  \brief Get address from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_port_desc_addr( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the EV3 port descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_port_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified EV3 port type.
 *  \param type_inx The EV3 port type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the EV3 port is found.
 */
extern bool ev3_search_port_type( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the EV3 port by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the EV3 port is found.
 */
extern bool ev3_search_port_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified EV3 port mode.
 *  \param mode_inx Index of the EV3 port mode.
 *  \return Requested value.
 */
extern const char *ev3_port_mode( INX_T mode_inx );

/**
 *  \brief Read "mode" attribute of the EV3 port and get the index.
 *  \param sn Sequence number.
 *  \param type_inx Index of the EV3 port type.
 *  \return Requested value.
 */
extern INX_T get_port_mode_inx( uint8_t sn, INX_T type_inx );

/**
 *  \brief Write "mode" attribute of the EV3 port by the index.
 *  \param sn Sequence number.
 *  \param mode_inx Index of the EV3 port mode.
 *  \return Count of written bytes.
 */
extern size_t set_port_mode_inx( uint8_t sn, INX_T mode_inx );

/**
 *  \brief Detect connected EV3 ports.
 *  \return The number of found EV3 ports or -1 in case of an error.
 */
extern int ev3_port_init( void );

/**
 *  \brief Identifiers of EV3 ports and extended ports.
 */
#define EV3_PORT__NONE_  0  /* XXX: 0 is used */
#define EXT_PORT__NONE_  EV3_PORT__NONE_

#define INPUT_1  49  // '1'
#define INPUT_2  50  // '2'
#define INPUT_3  51  // '3'
#define INPUT_4  52  // '4'
			
#define OUTPUT_A  65  // 'A'
#define OUTPUT_B  66  // 'B'
#define OUTPUT_C  67  // 'C'
#define OUTPUT_D  68  // 'D'
				
#define MUX_1  49  // '1'
#define MUX_2  50  // '2'
#define MUX_3  51  // '3'
#define MUX_4  52  // '4'
#define SERVO__OFFSET_  16
#define SERVO_1  65  // 'A'
#define SERVO_2  66  // 'B'
#define SERVO_3  67  // 'C'
#define SERVO_4  68  // 'D'
#define SERVO_5  69  // 'E'
#define SERVO_6  70  // 'F'
#define SERVO_7  71  // 'G'
#define SERVO_8  72  // 'H'
#define NXTMMX__OFFSET_  28
#define NXTMMX_1  77  // 'M'
#define NXTMMX_2  78  // 'N'
#define WEDO__OFFSET_  48
#define WEDO_1  97  // 'a'
#define WEDO_2  98  // 'b'
#define WEDO_3  99  // 'c'
#define WEDO_4  100  // 'd'

/**
 *  \brief Search of a port sequence number by the EV3 port and the extended port.
 *  \param port EV3 port index.
 *  \param extport Extended port index.
 *  \return Port sequence number.
 */
extern uint8_t ev3_search_port( uint8_t port, uint8_t extport );

/**
 *  \brief Parse name of the EV3 port.
 *  \param name Port name.
 *  \param port Buffer for the EV3 port index.
 *  \param extport Buffer for the extended port index.
 *  \param addr Buffer for the address.
 */
extern void ev3_parse_port_name( char *name, uint8_t *port, uint8_t *extport, uint8_t *addr );

/**
 *  \brief Assemble name of the EV3 port.
 *  \param port EV3 port index.
 *  \param extport Extended port index.
 *  \param addr Address.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_port_name( uint8_t port, uint8_t extport, uint8_t addr, char *buf );

#define SENSOR_DIR  "/sys/class/lego-sensor"  /**< Directory of sensors. */

/**
 *  \brief Structure of a sensor descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< Sensor type. */
	uint8_t port;  /**< Sensor EV3 port. */
	uint8_t extport;  /**< Sensor extended port. */
	uint8_t addr;  /**< Sensor address. */

} EV3_SENSOR;

#define SENSOR_DESC__LIMIT_  64  /**< Limit of sensor descriptors. */

#define SENSOR__NONE_  SENSOR_DESC__LIMIT_  /**< Sensor is not found. */

/**
 *  \brief Vector of sensor descriptors (filled by \ref ev3_sensor_init).
 */
extern EV3_SENSOR ev3_sensor[ SENSOR_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of sensor types.
 */
enum {
	SENSOR_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	EV3_ANALOG_XX,
	NXT_ANALOG,
	PIXY_LEGO,
	DI_DFLEX,
	HT_NXT_COLOR,
	HT_NXT_ANGLE,
	HT_NXT_ACCEL,
	HT_NXT_BAROMETRIC,
	HT_NXT_COLOR_V2,
	HT_NXT_EOPD,
	HT_NXT_FORCE,
	HT_NXT_GYRO,
	HT_NXT_IR_LINK,
	HT_NXT_IR_RECEIVER,
	HT_NXT_PIR,
	HT_NXT_COMPASS,
	HT_NXT_MAG,
	HT_NXT_IR_SEEK_V2,
	HT_NXT_SMUX,
	HT_SUPER_PRO,
	LEGO_EV3_US,
	LEGO_EV3_GYRO,
	LEGO_EV3_COLOR,
	LEGO_EV3_TOUCH,
	LEGO_EV3_IR,
	WEDO_HUB,
	WEDO_MOTION,
	WEDO_TILT,
	LEGO_POWER_STORAGE,
	LEGO_NXT_TOUCH,
	LEGO_NXT_LIGHT,
	LEGO_NXT_SOUND,
	LEGO_NXT_US,
	MI_XG1300L,
	MS_ABSOLUTE_IMU,
	MS_ANGLE,
	MS_EV3_SMUX,
	MS_LIGHT_ARRAY,
	MS_LINE_LEADER,
	MS_NXTCAM,
	MS_NXTMMX,
	MS_8CH_SERVO,
	MS_PIXY_ADAPTER,
	MS_NXT_TOUCH_MUX,

	SENSOR_TYPE__COUNT_,  /**< Count of sensor types. */
	SENSOR_TYPE__UNKNOWN_ = SENSOR_TYPE__COUNT_
};

/**
 *  \brief Identifiers of sensor modes.
 */
enum {
	SENSOR_MODE__NONE_ = 0,

	EV3_ANALOG_XX_ANALOG, 

	NXT_ANALOG_ANALOG_0, 
	NXT_ANALOG_ANALOG_1, 

	PIXY_LEGO_ALL, 
	PIXY_LEGO_SIG1, 
	PIXY_LEGO_SIG2, 
	PIXY_LEGO_SIG3, 
	PIXY_LEGO_SIG4, 
	PIXY_LEGO_SIG5, 
	PIXY_LEGO_SIG6, 
	PIXY_LEGO_SIG7, 
	PIXY_LEGO_COL_CODE, 
	PIXY_LEGO_ANGLE, 

	DI_DFLEX_FLEX, 

	HT_NXT_COLOR_COLOR, 
	HT_NXT_COLOR_RED, 
	HT_NXT_COLOR_GREEN, 
	HT_NXT_COLOR_BLUE, 
	HT_NXT_COLOR_RAW, 
	HT_NXT_COLOR_NORM, 
	HT_NXT_COLOR_ALL, 

	HT_NXT_ANGLE_ANGLE, 
	HT_NXT_ANGLE_ANGLE_ACC, 
	HT_NXT_ANGLE_SPEED, 

	HT_NXT_ACCEL_ACCEL, 
	HT_NXT_ACCEL_ALL, 

	HT_NXT_BAROMETRIC_PRESS, 
	HT_NXT_BAROMETRIC_TEMP, 

	HT_NXT_COLOR_V2_COLOR, 
	HT_NXT_COLOR_V2_RED, 
	HT_NXT_COLOR_V2_GREEN, 
	HT_NXT_COLOR_V2_BLUE, 
	HT_NXT_COLOR_V2_WHITE, 
	HT_NXT_COLOR_V2_NORM, 
	HT_NXT_COLOR_V2_ALL, 
	HT_NXT_COLOR_V2_RAW, 

	HT_NXT_EOPD_LONG, 
	HT_NXT_EOPD_SHORT, 

	HT_NXT_FORCE_FORCE, 

	HT_NXT_GYRO_GYRO, 

	HT_NXT_IR_LINK_IRLINK, 

	HT_NXT_IR_RECEIVER_1_MOTOR, 
	HT_NXT_IR_RECEIVER_8_MOTOR, 

	HT_NXT_PIR_PROX, 

	HT_NXT_COMPASS_COMPASS, 

	HT_NXT_MAG_MAG, 

	HT_NXT_IR_SEEK_V2_DC, 
	HT_NXT_IR_SEEK_V2_AC, 
	HT_NXT_IR_SEEK_V2_DC_ALL, 
	HT_NXT_IR_SEEK_V2_AC_ALL, 

	HT_NXT_SMUX_MUX, 

	HT_SUPER_PRO_AIN, 
	HT_SUPER_PRO_DIN, 
	HT_SUPER_PRO_DOUT, 
	HT_SUPER_PRO_DCTRL, 
	HT_SUPER_PRO_STROBE, 
	HT_SUPER_PRO_LED, 
	HT_SUPER_PRO_AOUT_0, 
	HT_SUPER_PRO_AOUT_1, 

	LEGO_EV3_US_US_DIST_CM, 
	LEGO_EV3_US_US_DIST_IN, 
	LEGO_EV3_US_US_LISTEN, 
	LEGO_EV3_US_US_SI_CM, 
	LEGO_EV3_US_US_SI_IN, 
	LEGO_EV3_US_US_DC_CM, 
	LEGO_EV3_US_US_DC_IN, 

	LEGO_EV3_GYRO_GYRO_ANG, 
	LEGO_EV3_GYRO_GYRO_RATE, 
	LEGO_EV3_GYRO_GYRO_FAS, 
	LEGO_EV3_GYRO_GYRO_G_AND_A, 
	LEGO_EV3_GYRO_GYRO_CAL, 

	LEGO_EV3_COLOR_COL_REFLECT, 
	LEGO_EV3_COLOR_COL_AMBIENT, 
	LEGO_EV3_COLOR_COL_COLOR, 
	LEGO_EV3_COLOR_REF_RAW, 
	LEGO_EV3_COLOR_RGB_RAW, 
	LEGO_EV3_COLOR_COL_CAL, 

	LEGO_EV3_TOUCH_TOUCH, 

	LEGO_EV3_IR_IR_PROX, 
	LEGO_EV3_IR_IR_SEEK, 
	LEGO_EV3_IR_IR_REMOTE, 
	LEGO_EV3_IR_IR_REM_A, 
	LEGO_EV3_IR_IR_S_ALT, 
	LEGO_EV3_IR_IR_CAL, 

	WEDO_HUB_HUB, 

	WEDO_MOTION_PROX, 
	WEDO_MOTION_RAW, 

	WEDO_TILT_TILT, 
	WEDO_TILT_TILT_AXIS, 
	WEDO_TILT_RAW, 

	LEGO_POWER_STORAGE_IN_VOLT, 
	LEGO_POWER_STORAGE_IN_AMP, 
	LEGO_POWER_STORAGE_OUT_VOLT, 
	LEGO_POWER_STORAGE_OUT_AMP, 
	LEGO_POWER_STORAGE_JOULE, 
	LEGO_POWER_STORAGE_IN_WATT, 
	LEGO_POWER_STORAGE_OUT_WATT, 
	LEGO_POWER_STORAGE_ALL, 

	LEGO_NXT_TOUCH_TOUCH, 

	LEGO_NXT_LIGHT_REFLECT, 
	LEGO_NXT_LIGHT_AMBIENT, 

	LEGO_NXT_SOUND_DB, 
	LEGO_NXT_SOUND_DBA, 

	LEGO_NXT_US_US_DIST_CM, 
	LEGO_NXT_US_US_DIST_IN, 
	LEGO_NXT_US_US_SI_CM, 
	LEGO_NXT_US_US_SI_IN, 
	LEGO_NXT_US_US_LISTEN, 

	MI_XG1300L_ANGLE, 
	MI_XG1300L_SPEED, 
	MI_XG1300L_ACCEL, 
	MI_XG1300L_ALL, 

	MS_ABSOLUTE_IMU_TILT, 
	MS_ABSOLUTE_IMU_ACCEL, 
	MS_ABSOLUTE_IMU_COMPASS, 
	MS_ABSOLUTE_IMU_MAG, 
	MS_ABSOLUTE_IMU_GYRO, 
	MS_ABSOLUTE_IMU_ALL, 

	MS_ANGLE_ANGLE, 
	MS_ANGLE_ANGLE2, 
	MS_ANGLE_SPEED, 
	MS_ANGLE_ALL, 

	MS_EV3_SMUX_MUX, 

	MS_LIGHT_ARRAY_CAL, 
	MS_LIGHT_ARRAY_RAW, 

	MS_LINE_LEADER_PID, 
	MS_LINE_LEADER_PID_ALL, 
	MS_LINE_LEADER_CAL, 
	MS_LINE_LEADER_RAW, 

	MS_NXTCAM_TRACK, 

	MS_NXTMMX_STATUS, 
	MS_NXTMMX_STATUS_OLD, 

	MS_8CH_SERVO_V3, 
	MS_8CH_SERVO_OLD, 

	MS_PIXY_ADAPTER_TRACK, 

	MS_NXT_TOUCH_MUX_TOUCH_MUX, 

	SENSOR_MODE__COUNT_,  /**< Count of sensor modes. */
	SENSOR_MODE__UNKNOWN_ = SENSOR_MODE__COUNT_
};

/**
 *  \brief Identifiers of sensor commands.
 */
enum {
	SENSOR_COMMAND__NONE_ = 0,

	HT_NXT_ANGLE_RESET, 
	HT_NXT_ANGLE_CAL, 

	HT_NXT_SMUX_HALT, 
	HT_NXT_SMUX_DETECT, 
	HT_NXT_SMUX_RUN, 

	WEDO_HUB_OUT_OFF, 
	WEDO_HUB_OUT_ON, 
	WEDO_HUB_CLEAR_ERR, 

	MI_XG1300L_RESET, 
	MI_XG1300L_ACCEL_2G, 
	MI_XG1300L_ACCEL_4G, 
	MI_XG1300L_ACCEL_8G, 

	MS_ABSOLUTE_IMU_BEGIN_COMP_CAL, 
	MS_ABSOLUTE_IMU_END_COMP_CAL, 
	MS_ABSOLUTE_IMU_ACCEL_2G, 
	MS_ABSOLUTE_IMU_ACCEL_4G, 
	MS_ABSOLUTE_IMU_ACCEL_8G, 
	MS_ABSOLUTE_IMU_ACCEL_16G, 

	MS_ANGLE_RESET, 

	MS_LIGHT_ARRAY_CAL_WHITE, 
	MS_LIGHT_ARRAY_CAL_BLACK, 
	MS_LIGHT_ARRAY_SLEEP, 
	MS_LIGHT_ARRAY_WAKE, 
	MS_LIGHT_ARRAY_60HZ, 
	MS_LIGHT_ARRAY_50HZ, 
	MS_LIGHT_ARRAY_UNIVERSAL, 

	MS_LINE_LEADER_CAL_WHITE, 
	MS_LINE_LEADER_CAL_BLACK, 
	MS_LINE_LEADER_SLEEP, 
	MS_LINE_LEADER_WAKE, 
	MS_LINE_LEADER_INV_COL, 
	MS_LINE_LEADER_RST_COL, 
	MS_LINE_LEADER_SNAP, 
	MS_LINE_LEADER_60HZ, 
	MS_LINE_LEADER_50HZ, 
	MS_LINE_LEADER_UNIVERSAL, 

	MS_NXTCAM_TRACK_ON, 
	MS_NXTCAM_TRACK_OFF, 
	MS_NXTCAM_TRACK_OBJ, 
	MS_NXTCAM_TRACK_LINE, 
	MS_NXTCAM_SORT_SIZE, 
	MS_NXTCAM_SORT_COL, 

	MS_PIXY_ADAPTER_SORT_SIZE, 
	MS_PIXY_ADAPTER_SORT_COL, 

	SENSOR_COMMAND__COUNT_,  /**< Count of sensor commands. */
	SENSOR_COMMAND__UNKNOWN_ = SENSOR_COMMAND__COUNT_
};

/**
 *  \brief Read "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data( uint8_t sn, byte *buf, size_t sz );

/**
 *  \brief Write "bin_data" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
 *  \param sz Size of attribute value.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_bin_data( uint8_t sn, byte *value, size_t sz );

/**
 *  \brief Read "bin_data_format" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_bin_data_format( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "command" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_command( uint8_t sn, char *value );

/**
 *  \brief Read "commands" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "direct" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_direct( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "direct" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_direct( uint8_t sn, char *value );

/**
 *  \brief Read "decimals" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_decimals( uint8_t sn, dword *buf );

/**
 *  \brief Read "driver_name" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "fw_version" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_fw_version( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_mode( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "mode" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_mode( uint8_t sn, char *value );

/**
 *  \brief Read "modes" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_modes( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "num_values" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_num_values( uint8_t sn, dword *buf );

/**
 *  \brief Read "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_poll_ms( uint8_t sn, dword *buf );

/**
 *  \brief Write "poll_ms" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_sensor_poll_ms( uint8_t sn, dword value );

/**
 *  \brief Read "port_name" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "units" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_units( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "value0" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value0( uint8_t sn, float *buf );

/**
 *  \brief Read "value1" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value1( uint8_t sn, float *buf );

/**
 *  \brief Read "value2" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value2( uint8_t sn, float *buf );

/**
 *  \brief Read "value3" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value3( uint8_t sn, float *buf );

/**
 *  \brief Read "value4" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value4( uint8_t sn, float *buf );

/**
 *  \brief Read "value5" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value5( uint8_t sn, float *buf );

/**
 *  \brief Read "value6" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value6( uint8_t sn, float *buf );

/**
 *  \brief Read "value7" attribute of the sensor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value7( uint8_t sn, float *buf );

/**
 *  \brief Read "value" attribute of the sensor.
 *  \param inx Attribute index.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
	 
 *  \return Count of read bytes.
 */
extern size_t get_sensor_value( uint8_t inx, uint8_t sn, int *buf );

/**
 *  \brief Get name of the specified sensor type.
 *  \param type_inx Index of the sensor type.
 *  \return Requested value.
 */
extern const char *ev3_sensor_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the sensor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_sensor_type_inx( uint8_t sn );

/**
 *  \brief Read the sensor attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_sensor_desc( uint8_t sn, EV3_SENSOR *desc );

/**
 *  \brief Get descriptor of the sensor.
 *  \param sn Sequence number.
 *  \return Pointer to the sensor descriptor.
 */
extern EV3_SENSOR *ev3_sensor_desc( uint8_t sn );

/**
 *  \brief Get type from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_sensor_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_extport( uint8_t sn );

/**
 *  \brief Get address from the sensor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_sensor_desc_addr( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the sensor descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_sensor_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified sensor type.
 *  \param type_inx The sensor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the sensor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the sensor is found.
 */
extern bool ev3_search_sensor_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified sensor mode.
 *  \param mode_inx Index of the sensor mode.
 *  \return Requested value.
 */
extern const char *ev3_sensor_mode( INX_T mode_inx );

/**
 *  \brief Read "mode" attribute of the sensor and get the index.
 *  \param sn Sequence number.
 *  \param type_inx Index of the sensor type.
 *  \return Requested value.
 */
extern INX_T get_sensor_mode_inx( uint8_t sn, INX_T type_inx );

/**
 *  \brief Write "mode" attribute of the sensor by the index.
 *  \param sn Sequence number.
 *  \param mode_inx Index of the sensor mode.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_mode_inx( uint8_t sn, INX_T mode_inx );

/**
 *  \brief Get name of the specified sensor command.
 *  \param command_inx Index of the sensor command.
 *  \return Requested value.
 */
extern const char *ev3_sensor_command( INX_T command_inx );

/**
 *  \brief Write "command" attribute of the sensor by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the sensor command.
 *  \return Count of written bytes.
 */
extern size_t set_sensor_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Detect connected sensors.
 *  \return The number of found sensors or -1 in case of an error.
 */
extern int ev3_sensor_init( void );

/**
 *  \brief Identifiers of LEGO_EV3_IR sensor values for IR_REMOTE mode.
 */
enum {
	IR_REMOTE__NONE_   = 0,

	RED_UP             = 1,
	RED_DOWN           = 2,
	BLUE_UP            = 3,
	BLUE_DOWN          = 4,
	RED_UP_BLUE_UP     = 5,
	RED_UP_BLUE_DOWN   = 6,
	RED_DOWN_BLUE_UP   = 7,
	RED_DOWN_BLUE_DOWN = 8,
	BEACON_MODE_ON     = 9,
	RED_UP_RED_DOWN    = 10,
	BLUE_UP_BLUE_DOWN  = 11,
};

#define TACHO_DIR  "/sys/class/tacho-motor"  /**< Directory of tachos. */

/**
 *  \brief Structure of a tacho descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< Tacho type. */
	uint8_t port;  /**< Tacho EV3 port. */
	uint8_t extport;  /**< Tacho extended port. */

} EV3_TACHO;

#define TACHO_DESC__LIMIT_  64  /**< Limit of tacho descriptors. */

#define TACHO__NONE_  TACHO_DESC__LIMIT_  /**< Tacho is not found. */

/**
 *  \brief Vector of tacho descriptors (filled by \ref ev3_tacho_init).
 */
extern EV3_TACHO ev3_tacho[ TACHO_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of tacho types.
 */
enum {
	TACHO_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	LEGO_EV3_L_MOTOR,
	LEGO_EV3_M_MOTOR,
	FI_L12_EV3,

	TACHO_TYPE__COUNT_,  /**< Count of tacho types. */
	TACHO_TYPE__UNKNOWN_ = TACHO_TYPE__COUNT_
};

/**
 *  \brief Identifiers of tacho commands.
 */
enum {
	TACHO_COMMAND__NONE_ = 0,

	LEGO_EV3_L_MOTOR_RUN_FOREVER, 
	LEGO_EV3_L_MOTOR_RUN_TO_ABS_POS, 
	LEGO_EV3_L_MOTOR_RUN_TO_REL_POS, 
	LEGO_EV3_L_MOTOR_RUN_TIMED, 
	LEGO_EV3_L_MOTOR_RUN_DIRECT, 
	LEGO_EV3_L_MOTOR_STOP, 
	LEGO_EV3_L_MOTOR_RESET, 

	LEGO_EV3_M_MOTOR_RUN_FOREVER, 
	LEGO_EV3_M_MOTOR_RUN_TO_ABS_POS, 
	LEGO_EV3_M_MOTOR_RUN_TO_REL_POS, 
	LEGO_EV3_M_MOTOR_RUN_TIMED, 
	LEGO_EV3_M_MOTOR_RUN_DIRECT, 
	LEGO_EV3_M_MOTOR_STOP, 
	LEGO_EV3_M_MOTOR_RESET, 

	FI_L12_EV3_RUN_FOREVER, 
	FI_L12_EV3_RUN_TO_ABS_POS, 
	FI_L12_EV3_RUN_TO_REL_POS, 
	FI_L12_EV3_RUN_TIMED, 
	FI_L12_EV3_RUN_DIRECT, 
	FI_L12_EV3_STOP, 
	FI_L12_EV3_RESET, 

	TACHO_COMMAND__COUNT_,  /**< Count of tacho commands. */
	TACHO_COMMAND__UNKNOWN_ = TACHO_COMMAND__COUNT_
};

/**
 *  \brief Identifiers of tacho stop_commands.
 */
enum {
	TACHO_STOP_COMMAND__NONE_ = 0,

	LEGO_EV3_L_MOTOR_COAST, 
	LEGO_EV3_L_MOTOR_BRAKE, 
	LEGO_EV3_L_MOTOR_HOLD, 

	LEGO_EV3_M_MOTOR_COAST, 
	LEGO_EV3_M_MOTOR_BRAKE, 
	LEGO_EV3_M_MOTOR_HOLD, 

	FI_L12_EV3_COAST, 
	FI_L12_EV3_BRAKE, 
	FI_L12_EV3_HOLD, 

	TACHO_STOP_COMMAND__COUNT_,  /**< Count of tacho stop_commands. */
	TACHO_STOP_COMMAND__UNKNOWN_ = TACHO_STOP_COMMAND__COUNT_
};

/**
 *  \brief Common identifiers of tacho commands.
 */
enum {
	TACHO_COMMAND__NULL_ = 0,

	TACHO_RUN_FOREVER,
	TACHO_RUN_TO_ABS_POS,
	TACHO_RUN_TO_REL_POS,
	TACHO_RUN_TIMED,
	TACHO_RUN_DIRECT,
	TACHO_STOP,
	TACHO_RESET,

};

/**
 *  \brief Common identifiers of tacho stop commands.
 */
enum {
	TACHO_STOP_COMMAND__NULL_ = 0,

	TACHO_COAST,
	TACHO_BRAKE,
	TACHO_HOLD,

};

/**
 *  \brief Common identifiers of tacho states.
 */
enum {
	TACHO_STATE__NONE_ = 0,

	TACHO_RUNNING = 0x1L,
	TACHO_RAMPING = 0x2L,
	TACHO_HOLDING = 0x4L,
	TACHO_STALLED = 0x8L,

};

/**
 *  \brief Write "command" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_command( uint8_t sn, char *value );

/**
 *  \brief Read "commands" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "count_per_rot" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_count_per_rot( uint8_t sn, int *buf );

/**
 *  \brief Read "driver_name" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "duty_cycle" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Read "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "duty_cycle_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Read "encoder_polarity" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_encoder_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "encoder_polarity" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_encoder_polarity( uint8_t sn, char *value );

/**
 *  \brief Read "hold_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_hold_pid_Kd( uint8_t sn, int *buf );

/**
 *  \brief Write "hold_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_hold_pid_Kd( uint8_t sn, int value );

/**
 *  \brief Read "hold_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_hold_pid_Ki( uint8_t sn, int *buf );

/**
 *  \brief Write "hold_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_hold_pid_Ki( uint8_t sn, int value );

/**
 *  \brief Read "hold_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_hold_pid_Kp( uint8_t sn, int *buf );

/**
 *  \brief Write "hold_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_hold_pid_Kp( uint8_t sn, int value );

/**
 *  \brief Read "polarity" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "polarity" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_polarity( uint8_t sn, char *value );

/**
 *  \brief Read "port_name" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position( uint8_t sn, int *buf );

/**
 *  \brief Write "position" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_position( uint8_t sn, int value );

/**
 *  \brief Read "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_position_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "position_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_position_sp( uint8_t sn, int value );

/**
 *  \brief Read "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_down_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_down_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_down_sp( uint8_t sn, int value );

/**
 *  \brief Read "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_ramp_up_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_up_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_ramp_up_sp( uint8_t sn, int value );

/**
 *  \brief Read "speed" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed( uint8_t sn, int *buf );

/**
 *  \brief Read "speed_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_pid_Kd( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_pid/Kd" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_pid_Kd( uint8_t sn, int value );

/**
 *  \brief Read "speed_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_pid_Ki( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_pid/Ki" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_pid_Ki( uint8_t sn, int value );

/**
 *  \brief Read "speed_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_pid_Kp( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_pid/Kp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_pid_Kp( uint8_t sn, int value );

/**
 *  \brief Read "speed_regulation" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_regulation( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "speed_regulation" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_regulation( uint8_t sn, char *value );

/**
 *  \brief Read "speed_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_speed_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "speed_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_speed_sp( uint8_t sn, int value );

/**
 *  \brief Read "state" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "stop_command" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_command( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "stop_command" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_stop_command( uint8_t sn, char *value );

/**
 *  \brief Read "stop_commands" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_stop_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_tacho_time_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "time_sp" attribute of the tacho.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_tacho_time_sp( uint8_t sn, int value );

/**
 *  \brief Get name of the specified tacho type.
 *  \param type_inx Index of the tacho type.
 *  \return Requested value.
 */
extern const char *ev3_tacho_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the tacho type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_tacho_type_inx( uint8_t sn );

/**
 *  \brief Read the tacho attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_desc( uint8_t sn, EV3_TACHO *desc );

/**
 *  \brief Get descriptor of the tacho.
 *  \param sn Sequence number.
 *  \return Pointer to the tacho descriptor.
 */
extern EV3_TACHO *ev3_tacho_desc( uint8_t sn );

/**
 *  \brief Get type from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_tacho_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the tacho descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_tacho_desc_extport( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the tacho descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_tacho_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified tacho type.
 *  \param type_inx The tacho type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the tacho by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the tacho is found.
 */
extern bool ev3_search_tacho_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified tacho command.
 *  \param command_inx Index of the tacho command.
 *  \return Requested value.
 */
extern const char *ev3_tacho_command( INX_T command_inx );

/**
 *  \brief Write "command" attribute of the tacho by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the tacho command.
 *  \return Count of written bytes.
 */
extern size_t set_tacho_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Get name of the specified tacho stop_command.
 *  \param stop_command_inx Index of the tacho stop_command.
 *  \return Requested value.
 */
extern const char *ev3_tacho_stop_command( INX_T stop_command_inx );

/**
 *  \brief Read "stop_command" attribute of the tacho and get the index.
 *  \param sn Sequence number.
 *  \param type_inx Index of the tacho type.
 *  \return Requested value.
 */
extern INX_T get_tacho_stop_command_inx( uint8_t sn, INX_T type_inx );

/**
 *  \brief Write "stop_command" attribute of the tacho by the index.
 *  \param sn Sequence number.
 *  \param stop_command_inx Index of the tacho stop_command.
 *  \return Count of written bytes.
 */
extern size_t set_tacho_stop_command_inx( uint8_t sn, INX_T stop_command_inx );

/**
 *  \brief Read "state" attribute of the tacho and get the flags.
 *  \param sn Sequence number.
 *  \param flags Buffer for the flags.
 *  \return Count of read bytes.
 */
extern size_t get_tacho_state_flags( uint8_t sn, FLAGS_T *flags );

/**
 *  \brief Detect connected tachos.
 *  \return The number of found tachos or -1 in case of an error.
 */
extern int ev3_tacho_init( void );

#define DC_DIR  "/sys/class/dc-motor"  /**< Directory of DC motors. */

/**
 *  \brief Structure of a DC motor descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< DC motor type. */
	uint8_t port;  /**< DC motor EV3 port. */
	uint8_t extport;  /**< DC motor extended port. */

} EV3_DC;

#define DC_DESC__LIMIT_  64  /**< Limit of DC motor descriptors. */

#define DC__NONE_  DC_DESC__LIMIT_  /**< DC motor is not found. */

/**
 *  \brief Vector of DC motor descriptors (filled by \ref ev3_dc_init).
 */
extern EV3_DC ev3_dc[ DC_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of DC motor types.
 */
enum {
	DC_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	RCX_MOTOR,

	DC_TYPE__COUNT_,  /**< Count of DC motor types. */
	DC_TYPE__UNKNOWN_ = DC_TYPE__COUNT_
};

/**
 *  \brief Identifiers of DC motor commands.
 */
enum {
	DC_COMMAND__NONE_ = 0,

	RCX_MOTOR_RUN_FOREVER, 
	RCX_MOTOR_RUN_TIMED, 
	RCX_MOTOR_RUN_DIRECT, 
	RCX_MOTOR_STOP, 

	DC_COMMAND__COUNT_,  /**< Count of DC motor commands. */
	DC_COMMAND__UNKNOWN_ = DC_COMMAND__COUNT_
};

/**
 *  \brief Identifiers of DC motor stop_commands.
 */
enum {
	DC_STOP_COMMAND__NONE_ = 0,

	RCX_MOTOR_COAST, 
	RCX_MOTOR_BRAKE, 

	DC_STOP_COMMAND__COUNT_,  /**< Count of DC motor stop_commands. */
	DC_STOP_COMMAND__UNKNOWN_ = DC_STOP_COMMAND__COUNT_
};

/**
 *  \brief Common identifiers of DC motor commands.
 */
enum {
	DC_COMMAND__NULL_ = 0,

	DC_RUN_FOREVER,
	DC_RUN_TIMED,
	DC_RUN_DIRECT,
	DC_STOP,

};

/**
 *  \brief Common identifiers of DC motor stop commands.
 */
enum {
	DC_STOP_COMMAND__NULL_ = 0,

	DC_COAST,
	DC_BRAKE,

};

/**
 *  \brief Common identifiers of DC motor states.
 */
enum {
	DC_STATE__NONE_ = 0,

	DC_RUNNING = 0x1L,
	DC_RAMPING = 0x2L,

};

/**
 *  \brief Write "command" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_command( uint8_t sn, char *value );

/**
 *  \brief Read "commands" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "driver_name" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "duty_cycle" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle( uint8_t sn, int *buf );

/**
 *  \brief Read "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_duty_cycle_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "duty_cycle_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_duty_cycle_sp( uint8_t sn, int value );

/**
 *  \brief Read "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "polarity" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_polarity( uint8_t sn, char *value );

/**
 *  \brief Read "port_name" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "state" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "stop_command" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_stop_command( uint8_t sn, char *value );

/**
 *  \brief Read "stop_commands" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_dc_stop_commands( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "ramp_down_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_down_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_down_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_down_sp( uint8_t sn, int value );

/**
 *  \brief Read "ramp_up_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_ramp_up_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "ramp_up_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_ramp_up_sp( uint8_t sn, int value );

/**
 *  \brief Read "time_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_dc_time_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "time_sp" attribute of the DC motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_dc_time_sp( uint8_t sn, int value );

/**
 *  \brief Get name of the specified DC motor type.
 *  \param type_inx Index of the DC motor type.
 *  \return Requested value.
 */
extern const char *ev3_dc_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the DC motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_dc_type_inx( uint8_t sn );

/**
 *  \brief Read the DC motor attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_dc_desc( uint8_t sn, EV3_DC *desc );

/**
 *  \brief Get descriptor of the DC motor.
 *  \param sn Sequence number.
 *  \return Pointer to the DC motor descriptor.
 */
extern EV3_DC *ev3_dc_desc( uint8_t sn );

/**
 *  \brief Get type from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_dc_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_dc_desc_extport( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the DC motor descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_dc_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified DC motor type.
 *  \param type_inx The DC motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the DC motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the DC motor is found.
 */
extern bool ev3_search_dc_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified DC motor command.
 *  \param command_inx Index of the DC motor command.
 *  \return Requested value.
 */
extern const char *ev3_dc_command( INX_T command_inx );

/**
 *  \brief Write "command" attribute of the DC motor by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the DC motor command.
 *  \return Count of written bytes.
 */
extern size_t set_dc_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Get name of the specified DC motor stop_command.
 *  \param stop_command_inx Index of the DC motor stop_command.
 *  \return Requested value.
 */
extern const char *ev3_dc_stop_command( INX_T stop_command_inx );

/**
 *  \brief Write "stop_command" attribute of the DC motor by the index.
 *  \param sn Sequence number.
 *  \param stop_command_inx Index of the DC motor stop_command.
 *  \return Count of written bytes.
 */
extern size_t set_dc_stop_command_inx( uint8_t sn, INX_T stop_command_inx );

/**
 *  \brief Read "state" attribute of the DC motor and get the flags.
 *  \param sn Sequence number.
 *  \param flags Buffer for the flags.
 *  \return Count of read bytes.
 */
extern size_t get_dc_state_flags( uint8_t sn, FLAGS_T *flags );

/**
 *  \brief Detect connected DC motors.
 *  \return The number of found DC motors or -1 in case of an error.
 */
extern int ev3_dc_init( void );

#define SERVO_DIR  "/sys/class/servo-motor"  /**< Directory of servo motors. */

/**
 *  \brief Structure of a servo motor descriptor.
 */
typedef struct {
	INX_T type_inx;  /**< Servo motor type. */
	uint8_t port;  /**< Servo motor EV3 port. */
	uint8_t extport;  /**< Servo motor extended port. */
	uint8_t addr;  /**< Servo motor address. */

} EV3_SERVO;

#define SERVO_DESC__LIMIT_  64  /**< Limit of servo motor descriptors. */

#define SERVO__NONE_  SERVO_DESC__LIMIT_  /**< Servo motor is not found. */

/**
 *  \brief Vector of servo motor descriptors (filled by \ref ev3_servo_init).
 */
extern EV3_SERVO ev3_servo[ SERVO_DESC__LIMIT_ ];

/**
 *  \brief Identifiers of servo motor types.
 */
enum {
	SERVO_TYPE__NONE_ = 0,  /* XXX: memset( 0 ) is used */

	SERVO_MOTOR,

	SERVO_TYPE__COUNT_,  /**< Count of servo motor types. */
	SERVO_TYPE__UNKNOWN_ = SERVO_TYPE__COUNT_
};

/**
 *  \brief Identifiers of servo motor commands.
 */
enum {
	SERVO_COMMAND__NONE_ = 0,

	SERVO_MOTOR_RUN, 
	SERVO_MOTOR_FLOAT, 

	SERVO_COMMAND__COUNT_,  /**< Count of servo motor commands. */
	SERVO_COMMAND__UNKNOWN_ = SERVO_COMMAND__COUNT_
};

/**
 *  \brief Common identifiers of servo motor commands.
 */
enum {
	SERVO_COMMAND__NULL_ = 0,

	SERVO_RUN,
	SERVO_FLOAT,

};

/**
 *  \brief Common identifiers of servo motor states.
 */
enum {
	SERVO_STATE__NONE_ = 0,

	SERVO_RUNNING = 0x1L,

};

/**
 *  \brief Read "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_command( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "command" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_command( uint8_t sn, char *value );

/**
 *  \brief Read "driver_name" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_driver_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "max_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_max_pulse_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "max_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_max_pulse_sp( uint8_t sn, int value );

/**
 *  \brief Read "mid_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_mid_pulse_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "mid_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_mid_pulse_sp( uint8_t sn, int value );

/**
 *  \brief Read "min_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_min_pulse_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "min_pulse_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_min_pulse_sp( uint8_t sn, int value );

/**
 *  \brief Read "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_polarity( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Write "polarity" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_polarity( uint8_t sn, char *value );

/**
 *  \brief Read "port_name" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_port_name( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Read "position_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_position_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "position_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_position_sp( uint8_t sn, int value );

/**
 *  \brief Read "rate_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
		 
 *  \return Count of read bytes.
 */
extern size_t get_servo_rate_sp( uint8_t sn, int *buf );

/**
 *  \brief Write "rate_sp" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param value Attribute value.
		 
 *  \return Count of written bytes.
 */
extern size_t set_servo_rate_sp( uint8_t sn, int value );

/**
 *  \brief Read "state" attribute of the servo motor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \param sz Buffer size.
 *  \return Count of read bytes.
 */
extern size_t get_servo_state( uint8_t sn, char *buf, size_t sz );

/**
 *  \brief Get name of the specified servo motor type.
 *  \param type_inx Index of the servo motor type.
 *  \return Requested value.
 */
extern const char *ev3_servo_type( INX_T type_inx );

/**
 *  \brief Read "driver_name" attribute and get index of the servo motor type.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T get_servo_type_inx( uint8_t sn );

/**
 *  \brief Read the servo motor attributes that are required for filling the descriptor.
 *  \param sn Sequence number.
 *  \param desc Buffer for the descriptor.
 *  \return Count of read bytes.
 */
extern size_t get_servo_desc( uint8_t sn, EV3_SERVO *desc );

/**
 *  \brief Get descriptor of the servo motor.
 *  \param sn Sequence number.
 *  \return Pointer to the servo motor descriptor.
 */
extern EV3_SERVO *ev3_servo_desc( uint8_t sn );

/**
 *  \brief Get type from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern INX_T ev3_servo_desc_type_inx( uint8_t sn );

/**
 *  \brief Get EV3 port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_port( uint8_t sn );

/**
 *  \brief Get extended port from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_extport( uint8_t sn );

/**
 *  \brief Get address from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \return Requested value.
 */
extern uint8_t ev3_servo_desc_addr( uint8_t sn );

/**
 *  \brief Assemble EV3 port name from the servo motor descriptor.
 *  \param sn Sequence number.
 *  \param[out] buf Buffer for result.
 *  \return Requested value.
 */
extern char *ev3_servo_port_name( uint8_t sn, char *buf );

/**
 *  \brief Search of a sequence number of the specified servo motor type.
 *  \param type_inx The servo motor type.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo( INX_T type_inx, uint8_t *sn, uint8_t from );

/**
 *  \brief Search of a sequence number the servo motor by plug-in attributes.
 *  \param port EV3 port.
 *  \param extport Extended port.
 *  \param[out] sn Buffer for the sequence number.
 *  \param from Search initial value.
 *  \return Flag - the servo motor is found.
 */
extern bool ev3_search_servo_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );

/**
 *  \brief Get name of the specified servo motor command.
 *  \param command_inx Index of the servo motor command.
 *  \return Requested value.
 */
extern const char *ev3_servo_command( INX_T command_inx );

/**
 *  \brief Read "command" attribute of the servo motor and get the index.
 *  \param sn Sequence number.
 *  \param type_inx Index of the servo motor type.
 *  \return Requested value.
 */
extern INX_T get_servo_command_inx( uint8_t sn, INX_T type_inx );

/**
 *  \brief Write "command" attribute of the servo motor by the index.
 *  \param sn Sequence number.
 *  \param command_inx Index of the servo motor command.
 *  \return Count of written bytes.
 */
extern size_t set_servo_command_inx( uint8_t sn, INX_T command_inx );

/**
 *  \brief Read "state" attribute of the servo motor and get the flags.
 *  \param sn Sequence number.
 *  \param flags Buffer for the flags.
 *  \return Count of read bytes.
 */
extern size_t get_servo_state_flags( uint8_t sn, FLAGS_T *flags );

/**
 *  \brief Detect connected servo motors.
 *  \return The number of found servo motors or -1 in case of an error.
 */
extern int ev3_servo_init( void );

